package com.example.pix.keys.service;

import com.example.pix.keys.store.PixKeyRecord;
import com.example.pix.keys.store.PortabilityClaimRecord;
import com.example.pix.keys.validator.KeyValidator;
import com.example.pix.keys.v1.ConfirmPortabilityRequest;
import com.example.pix.keys.v1.ConfirmPortabilityResponse;
import com.example.pix.keys.v1.DeleteKeyRequest;
import com.example.pix.keys.v1.DeleteKeyResponse;
import com.example.pix.keys.v1.InitiatePortabilityRequest;
import com.example.pix.keys.v1.InitiatePortabilityResponse;
import com.example.pix.keys.v1.KeyManagementServiceGrpc;
import com.example.pix.keys.v1.KeyType;
import com.example.pix.keys.v1.LookupKeyRequest;
import com.example.pix.keys.v1.LookupKeyResponse;
import com.example.pix.keys.v1.PixKey;
import com.example.pix.keys.v1.PortabilityClaim;
import com.example.pix.keys.v1.PortabilityClaimState;
import com.example.pix.keys.v1.RegisterKeyRequest;
import com.example.pix.keys.v1.RegisterKeyResponse;
import io.grpc.Status;
import io.grpc.stub.StreamObserver;
import net.devh.boot.grpc.server.service.GrpcService;

/**
 * gRPC service implementation for KeyManagementService.
 * Translates gRPC requests to domain operations and maps errors to gRPC status codes.
 *
 * <p>Classes in com.example.pix.keys.v1 are generated by the protobuf Gradle plugin
 * from proto/keys.proto at build time (./gradlew build or make proto-gen).
 */
@GrpcService
public class KeyManagementGrpcService extends KeyManagementServiceGrpc.KeyManagementServiceImplBase {

    private final KeyManagementService svc;

    public KeyManagementGrpcService(KeyManagementService svc) {
        this.svc = svc;
    }

    @Override
    public void registerKey(RegisterKeyRequest request, StreamObserver<RegisterKeyResponse> responseObserver) {
        try {
            KeyValidator.KeyType keyType = protoKeyType(request.getKeyType());
            PixKeyRecord record = svc.registerKey(
                request.getKey(), keyType, request.getOwnerId(),
                request.getAccountHolder(), request.getAccountBranch(), request.getAccountNumber()
            );
            responseObserver.onNext(RegisterKeyResponse.newBuilder()
                .setPixKey(toProto(record)).build());
            responseObserver.onCompleted();
        } catch (KeyException e) {
            responseObserver.onError(mapException(e));
        }
    }

    @Override
    public void lookupKey(LookupKeyRequest request, StreamObserver<LookupKeyResponse> responseObserver) {
        try {
            PixKeyRecord record = svc.lookupKey(request.getKey());
            responseObserver.onNext(LookupKeyResponse.newBuilder()
                .setPixKey(toProto(record)).build());
            responseObserver.onCompleted();
        } catch (KeyException e) {
            responseObserver.onError(mapException(e));
        }
    }

    @Override
    public void deleteKey(DeleteKeyRequest request, StreamObserver<DeleteKeyResponse> responseObserver) {
        try {
            svc.deleteKey(request.getKey(), request.getOwnerId());
            responseObserver.onNext(DeleteKeyResponse.newBuilder().build());
            responseObserver.onCompleted();
        } catch (KeyException e) {
            responseObserver.onError(mapException(e));
        }
    }

    @Override
    public void initiatePortability(InitiatePortabilityRequest request,
                                    StreamObserver<InitiatePortabilityResponse> responseObserver) {
        try {
            PortabilityClaimRecord claim = svc.initiatePortability(
                request.getKey(), request.getRequestingOwner());
            responseObserver.onNext(InitiatePortabilityResponse.newBuilder()
                .setClaim(toProtoClaim(claim)).build());
            responseObserver.onCompleted();
        } catch (KeyException e) {
            responseObserver.onError(mapException(e));
        }
    }

    @Override
    public void confirmPortability(ConfirmPortabilityRequest request,
                                   StreamObserver<ConfirmPortabilityResponse> responseObserver) {
        try {
            PixKeyRecord record = svc.confirmPortability(
                request.getClaimId(), request.getConfirmingOwner());
            responseObserver.onNext(ConfirmPortabilityResponse.newBuilder()
                .setPixKey(toProto(record)).build());
            responseObserver.onCompleted();
        } catch (KeyException e) {
            responseObserver.onError(mapException(e));
        }
    }

    // ── Mapping helpers ───────────────────────────────────────────────────────

    private static PixKey toProto(PixKeyRecord r) {
        return PixKey.newBuilder()
            .setKey(r.key)
            .setKeyType(KeyType.forNumber(KeyValidator.KeyType.valueOf(r.keyType).ordinal()))
            .setAccountHolder(r.accountHolder)
            .setAccountBranch(r.accountBranch)
            .setAccountNumber(r.accountNumber)
            .setOwnerId(r.ownerId)
            .setCreatedAtUnix(r.createdAt.getEpochSecond())
            .build();
    }

    private static PortabilityClaim toProtoClaim(PortabilityClaimRecord c) {
        return PortabilityClaim.newBuilder()
            .setClaimId(c.claimId)
            .setKey(c.key)
            .setRequestingOwner(c.requestingOwner)
            .setState(PortabilityClaimState.valueOf("PORTABILITY_CLAIM_STATE_" + c.state))
            .setInitiatedAtUnix(c.initiatedAt.getEpochSecond())
            .setExpiresAtUnix(c.expiresAt.getEpochSecond())
            .build();
    }

    private static KeyValidator.KeyType protoKeyType(KeyType protoType) {
        return switch (protoType) {
            case KEY_TYPE_CPF    -> KeyValidator.KeyType.CPF;
            case KEY_TYPE_CNPJ   -> KeyValidator.KeyType.CNPJ;
            case KEY_TYPE_EMAIL  -> KeyValidator.KeyType.EMAIL;
            case KEY_TYPE_PHONE  -> KeyValidator.KeyType.PHONE;
            case KEY_TYPE_RANDOM -> KeyValidator.KeyType.RANDOM;
            default -> throw new KeyException("INVALID_KEY_TYPE: unsupported key type " + protoType);
        };
    }

    private static io.grpc.StatusRuntimeException mapException(KeyException e) {
        String msg = e.getMessage();
        if (msg.startsWith("KEY_NOT_FOUND") || msg.startsWith("CLAIM_NOT_FOUND")) {
            return Status.NOT_FOUND.withDescription(msg).asRuntimeException();
        } else if (msg.startsWith("KEY_ALREADY_EXISTS")) {
            return Status.ALREADY_EXISTS.withDescription(msg).asRuntimeException();
        } else if (msg.startsWith("KEY_OWNERSHIP_MISMATCH")) {
            return Status.PERMISSION_DENIED.withDescription(msg).asRuntimeException();
        } else {
            return Status.INVALID_ARGUMENT.withDescription(msg).asRuntimeException();
        }
    }
}
